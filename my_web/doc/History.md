## 版本历史 

从一开始看<<Linux高性能服务器编程>>,开始想写一个属于自己的东西.后来遇到了muduo,下决心进行重写.说实话,我并没有看懂muduo,自己编写网络程序的经验太少,书中讲过的很多东西并没有太多的体会.再到后来,想以自己的能力写一个东西,我觉得自己很笨,想着自己能写到什么程度,就写到什么程度,一边鼓励自己一边开始了重写.

####  第一版

第一版是学习<<Linux高性能服务器编程>>和其他人写的博客,加上自己的想法.

使用结构

- epoll et + 非阻塞IO 

- 使用一个固定线程的线程池

- 解析HTTP的Get,Post请求

- 线程的任务:

- 来一个连接投放到任务队列中,线程被唤醒,执行具体的IO操作和计算任务

- 如果不监听从epoll中删除

- 任务队列的添加和取出,需要通过加锁,并且配合条件变量

- ...

  第一版并没有考虑缓冲区溢出的问题,没有考虑业务上的线程安全问题,没有定时器等功能,没有使用c++的新特性,仍然是函数指针等问题,缺陷很多



#### 第二版

第二版是看过muduo之后,对其中内容的实践学习,希望加深自己的体会:

- 所有的裸指针修改为指针指针
- 使用vector作为缓冲区
- 使用one loop per thread ,每一个线程一个epoll ,由主线程进行连接的分发，给IO线程进行相应的操作
- 将pthread和pthread_mutex_lock等换为 std::thread,std::mutex等
- 调整了类的结构,让每一个类拥有单一职能.
- 为不提供拷贝构造和赋值运算符的类添加了noncopyable类
- 使用std::bind 和 std::function来代替函数指针
- 注意到了生命周期的问题
- ...

#### 第三版

在我想要在多个CPU上调用accept系统调用,进而去查阅相关的资料,所做的一次尝试:

- 使用`EPOLLEXCLUSIVE`选项,多个线程同时共享一个epollfd,同一个listenfd,`EPOLLEXCLUSIVE`保证一个事件只有一个epoll_wait()会被唤醒,可以在多个CPU上扩展

- 使用了享元模式,减少频繁创建对象的消耗

- 添加`epolloneshot`选项避免数据竞争

- ....

  在经过测试之后,发现并不完全保证业务上的线程安全,也可能是我的水平比较差的原因

#### 最终版

- 使用`ReusePort`来代替`EPOLLEXCLUSIVE`,每一个线程有各自的epollfd和listenfd,由内核来做负载均衡
- 使用`string_view`来代替`const string &`提高性能
- 使用`unordered_map` 和`vector`构建定时器,std::chrono得到当前时间

- 将状态机重写

- 优化类结构

- ....

  最终版的详细结构在`模型结构`中详细说明,在这里只想记录一下,一个小白的学习过程,鼓励自己继续加油




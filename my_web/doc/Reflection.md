### Reflection

主要进行设计反思和自我思索,在这里向自己提出一些问题,以自己的理解解答.

##### ReusePort是一种良好的方案吗?

- `ReusePort`是一种套接字复用机制,允许将多个套接字bind到同一个IP/端口上，通过内核层面上进行负载均衡,单个Reactor是没有锁．

- `ReusePort`有两种方式,热备份模式和负载均衡模式,但是在内核3.9+之后,所有的是负载均衡．

- 热备份:创建N个reuseport套接字,只有一个可以使用，当这个套接字挂了才会被后一个取代．

- 负载均衡:当连接来临的时候,系统会取一个套接字处理，达到负载均衡

- 热备份:将所有的套接字挂到一个链表中,取其中的一个,如果一个套接字挂了,那么会从链表中删除,后一个会补上

- 负载均衡,同样会作为一个链表,但是连接来临`数据包的IP/端口`作为一个HASH函数的输入,根据结果来取出套接字

  ###### 那么一个连接会被不同的套接字处理吗?

  不会.观察算法,相同的连接(五元组)得到的HASH结果是一样的,可以避免竞争.

  ###### ReusePort的弊端是什么?

  如果有一个线程阻塞中,继续分配连接,会一直阻塞在那个地方. 如果其中一个listenfd关掉,那么这个listenfd上的accept队列上的东西会被全部丢弃.

##### 定时器如何实现更加合理?

- 一开始计划使用stl中的优先队列(`priority_queue`),但是它不能够更新连接时间,然后放弃.

- 定时器需要快速根据当前时间找到已经到期的Timer,而且也需要快速的添加和删除Timer,而且时间的更新需要尽可能不受影响

- 选择std::chrono::steady_clock::now(),获取自boost启动的时候,不受用户调整系统时间的影响.

- vector+unordered_map实现最大堆,用unordered_map记住timer在heap堆中的位置.加快了查找效率,实现了基本的需求

  

##### 该场景适合享元模式吗?

- 享元模式是运用共享技术有效地支持大量细粒度的对象,我们可以创建一个对象池,如果来新的用户,创建相应的Buffer.连接用户如果已经在池中注册,则直接分配.尽可能的减少大量new/delete的消耗.

- 每一个线程创建一个对象池,这样可以避免数据竞争的问题

##### 关于安全性的思考?

- 考虑到传输过程中的不安全性,计划支持https,在http层下面进行tls加密.查询相关资料,学习到openssl可以实现相关功能.起初以自签名的证书实现相关功能,但是经过测试,发现自签名的证书,只能在开发的时候使用,在公网上是无效的。随之放弃,之后如果有有效证书,则会进行支持https.


  



































